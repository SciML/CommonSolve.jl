var documenterSearchIndex = {"docs":
[{"location":"#CommonSolve.jl:-The-Common-Solve-Definition-and-Interface","page":"The Common Solve Interface","title":"CommonSolve.jl: The Common Solve Definition and Interface","text":"This holds the common solve, init, solve!, and step! commands. By using the same definition, solver libraries from entirely different ecosystems can extend the functions and thus not clash with SciML if both ecosystems export the solve command. The rules are that you must dispatch on one of your own types. That's it. No pirates.","category":"section"},{"location":"#Installation","page":"The Common Solve Interface","title":"Installation","text":"To install CommonSolve.jl, use the Julia package manager:\n\nusing Pkg\nPkg.add(\"CommonSolve\")","category":"section"},{"location":"#General-recommendation","page":"The Common Solve Interface","title":"General recommendation","text":"solve function has the default definition\n\nsolve(args...; kwargs...) = solve!(init(args...; kwargs...))\n\nSo, we recommend defining\n\ninit(::ProblemType, args...; kwargs...)::SolverType\nsolve!(::SolverType)::SolutionType\n\nwhere ProblemType, SolverType, and SolutionType are the types defined in your package.\n\nIn many cases, the SolverType is an object that is iteratively progressed to achieve the solution. In such cases, the step! function can be used:\n\nstep!(::SolverType, args...; kwargs...)\n\nTo avoid method ambiguity, the first argument of solve, solve!, step!, and init must be dispatched on the type defined in your package.  For example, do not define a method such as\n\ninit(::AbstractVector, ::AlgorithmType)","category":"section"},{"location":"#API","page":"The Common Solve Interface","title":"API","text":"","category":"section"},{"location":"#Contributing","page":"The Common Solve Interface","title":"Contributing","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing to SciML.\nSee the SciML Style Guide for common coding practices and other style decisions.\nThere are a few community forums:\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Slack\nThe #diffeq-bridged and #sciml-bridged channels in the Julia Zulip\nOn the Julia Discourse forums\nSee also SciML Community page","category":"section"},{"location":"#Reproducibility","page":"The Common Solve Interface","title":"Reproducibility","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>\n\nusing Pkg # hide\nPkg.status() # hide\n\n</details>\n\n<details><summary>and using this machine and Julia version.</summary>\n\nusing InteractiveUtils # hide\nversioninfo() # hide\n\n</details>\n\n<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>\n\nusing Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>\n\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"section"},{"location":"#CommonSolve.init","page":"The Common Solve Interface","title":"CommonSolve.init","text":"iter = CommonSolve.init(args...; kwargs...)\n\nCreates an iterator or cache object to hold a problem prob and a solver algorithm alg to be passed to solve! or step!. Generally, the interface is:\n\niter = CommonSolve.init(prob::ProblemType, alg::SolverType; kwargs...)::IterType\nCommonSolve.solve!(iter)::SolutionType\n\nwhere the keyword arguments are uniform across all choices of algorithms. The iter type will be different for the different problem types.\n\nThe object returned by init allows more direct control over the internal solving process, and users shouldn't generally need to handle it.\n\n\n\n\n\n","category":"function"},{"location":"#CommonSolve.solve","page":"The Common Solve Interface","title":"CommonSolve.solve","text":"CommonSolve.solve(args...; kwargs...)\n\nSolves an equation or other mathematical problem using the algorithm specified in the arguments. Generally, the interface is:\n\nCommonSolve.solve(prob::ProblemType, alg::SolverType; kwargs...)::SolutionType\n\nwhere the keyword arguments are uniform across all choices of algorithms.\n\nBy default, solve defaults to using solve! on the iterator form, i.e.:\n\nsolve(args...; kwargs...) = solve!(init(args...; kwargs...))\n\n\n\n\n\n","category":"function"},{"location":"#CommonSolve.solve!","page":"The Common Solve Interface","title":"CommonSolve.solve!","text":"CommonSolve.solve!(iter)\n\nSolves an equation or other mathematical problem using the algorithm specified in the arguments. Generally, the interface is:\n\niter = CommonSolve.init(prob::ProblemType, alg::SolverType; kwargs...)::IterType\nCommonSolve.solve!(iter)::SolutionType\n\nwhere the keyword arguments are uniform across all choices of algorithms. The iter type will be different for the different problem types.\n\n\n\n\n\n","category":"function"},{"location":"#CommonSolve.step!","page":"The Common Solve Interface","title":"CommonSolve.step!","text":"CommonSolve.step!(iter, args...; kwargs...)\n\nProgress the iterator object (the one returned by CommonSolve.init). The additional arguments typically describe how much to progress the iterator for, and are implementation-specific.\n\n\n\n\n\n","category":"function"}]
}
